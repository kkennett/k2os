//   
//   BSD 3-Clause License
//   
//   Copyright (c) 2023, Kurt Kennett
//   All rights reserved.
//   
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions are met:
//   
//   1. Redistributions of source code must retain the above copyright notice, this
//      list of conditions and the following disclaimer.
//   
//   2. Redistributions in binary form must reproduce the above copyright notice,
//      this list of conditions and the following disclaimer in the documentation
//      and/or other materials provided with the distribution.
//   
//   3. Neither the name of the copyright holder nor the names of its
//      contributors may be used to endorse or promote products derived from
//      this software without specific prior written permission.
//   
//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
//   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//   CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
#ifndef __K2DBUS_H
#define __K2DBUS_H

#include <k2systype.h>

#ifdef __cplusplus
extern "C" {
#endif

//
//------------------------------------------------------------------------
//

#define K2DBUS_PROTO_VERSION        1

#define K2DBUS_STRUCT_ALIGN         8

#define K2DBUS_MSG_LITTLE_ENDIAN    'l'
#define K2DBUS_MSG_BIG_ENDIAN       'B'

#define K2DBUS_NAME_MAX_LEN         255

#define K2DBUS_MAX_ARRAY_DEPTH      64

#define K2DBUS_ALIGNED(x,y)         (((x) % (y)) == 0)

K2_PACKED_PUSH
typedef struct _K2DBUS_SIG_TYPE K2DBUS_SIG_TYPE;
struct _K2DBUS_SIG_TYPE
{
    char            mChar;
    UINT8           mEnum;
    UINT16          mAlign;
    char const *    mpName;
} K2_PACKED_ATTRIB;
K2_PACKED_POP

typedef enum _K2DBUS_SigType K2DBUS_SigType;
enum _K2DBUS_SigType
{
    K2DBUS_SigType_Invalid = 0,

    K2DBUS_Sig_ARRAY,       // 'a'   4
    K2DBUS_Sig_BOOLEAN,     // 'b'   4
    K2DBUS_Sig_DOUBLE,      // 'd'   8
    K2DBUS_Sig_DICTENT,     // 'e'   8
    K2DBUS_Sig_FLOAT,       // 'f'   4
    K2DBUS_Sig_SIG,         // 'g'   1
    K2DBUS_Sig_TOKEN,       // 'h'   4
    K2DBUS_Sig_INT32,       // 'i'   4
    K2DBUS_Sig_INT16,       // 'n'   2
    K2DBUS_Sig_OBJPATH,     // 'o'   4
    K2DBUS_Sig_UINT16,      // 'q'   2
    K2DBUS_Sig_STRUCT,      // 'r'   8
    K2DBUS_Sig_STRZ,        // 's'   4
    K2DBUS_Sig_UINT64,      // 't'   8
    K2DBUS_Sig_UINT32,      // 'u'   4
    K2DBUS_Sig_VARIANT,     // 'v'   1
    K2DBUS_Sig_INT64,       // 'x'   8
    K2DBUS_Sig_BYTE,        // 'y'   1

    K2DBUS_SigType_Count
};

extern K2DBUS_SIG_TYPE const gK2DBUS_Types[K2DBUS_SigType_Count];

typedef enum _K2DBUG_MsgType K2DBUS_MsgType;
enum _K2DBUS_MsgType
{
    K2DBUS_MsgType_Invalid = 0,

    K2DBUS_Msg_MethodCall = 1,      // PATH and MEMBER fields required; Can have INTERFACE and/or SIGNATURE
                                    // SENDER is inserted by bus in routing
    K2DBUS_Msg_MethodReturn = 2,    // REPLY_SERIAL field requried; nonempty result requires SIGNATURE
    K2DBUS_Msg_Error = 3,           // ERROR_NAME field required;
    K2DBUS_Msg_Signal = 4,          // PATH, INTERFACE, MEMBER required; Can have SIGNATURE

    K2DBUS_MsgType_Count
};

#define K2DBUS_MSGHDR_FLAG_NO_REPLY_EXPECTED    1

K2_PACKED_PUSH
typedef struct _K2DBUS_MSGHDR K2DBUS_MSGHDR;
struct _K2DBUS_MSGHDR
{
    // yyyyuua(yv)
    UINT8   mEndian;            // 'l'
    UINT8   mMsgType;           // K2DBUS_MsgType
    UINT8   mFlags;             // 0 or K2DBUS_MSGHDR_FLAG_NO_REPLY_EXPECTED
    UINT8   mProtoVer;          // 1
    UINT32  mBodyByteCount;     // this plus the size of the header field array should = the size of the whole message
    UINT32  mSerialNo;          // auto-generated by bus router
} K2_PACKED_ATTRIB;
K2_PACKED_POP
// followed by header fields array.
// each struct in the array following the 4-byte count of the size of the struct array is 8-byte aligned
// struct (yv) so align 8, then byte followed by variant;  byte is one of K2DBUS_MsgHdrFieldType
// and the variant is a signature followed by marshalled data that corresponds to the signature
// 
// the message body follows at 8-byte alignment

typedef enum _K2DBUS_MsgHdrFieldType K2DBUS_MsgHdrFieldType;
enum _K2DBUS_MsgHdrFieldType
{
    K2DBUS_MsgHdrFieldType_Invalid = 0,

    K2DBUS_MsgHdrField_PATH = 1,            // K2DBUS_Sig_OBJPATH   is conn + object;  target for METHOD_CALL, source for SIGNAL
    K2DBUS_MsgHdrField_INTERFACE = 2,       // K2DBUS_Sig_STRING    optional for METHOD_CALL, required as source of SIGNAL 
    K2DBUS_MsgHdrField_MEMBER = 3,          // K2DBUS_Sig_STRING
    K2DBUS_MsgHdrField_ERROR_NAME = 4,      // K2DBUS_Sig_STRING
    K2DBUS_MsgHdrField_REPLY_SERIAL = 5,    // K2DBUS_Sig_UINT32    for collation with reply
    K2DBUS_MsgHdrField_DESTINATION = 6,     // K2DBUS_Sig_STRING    connection 
    K2DBUS_MsgHdrField_SENDER = 7,          // K2DBUS_Sig_STRING    auto-generated by bus router
    K2DBUS_MsgHdrField_SIGNATURE = 8,       // K2DBUS_Sig_SIGNATURE if missing, body does not correspond to a structure or there is no body

    K2DBUS_MsgHdrFieldType_Count
};

typedef struct _K2DBUS_PARSE K2DBUS_PARSE;
struct _K2DBUS_PARSE
{
    char const *mpSig;
    UINT32      mSigLen;
    UINT32      mMemAddr;
    UINT32      mMemLeft;
};

//
//------------------------------------------------------------------------
//

K2DBUS_SigType K2DBUS_FindSigType(char aCh);

BOOL K2DBUS_AlignUp(UINT32 *apAddr, UINT32 *apLeft, UINT32 aAlignTo);

K2STAT K2DBUS_SigIsWellFormed(char const *apSig, UINT32 aMaxLen, UINT32 *apRetSigLen);

BOOL K2DBUS_StringIsValidObjPath(char const *apStr);
BOOL K2DBUS_StringIsValidInterface(char const *apStr);
BOOL K2DBUS_StringIsValidMemberName(char const *apStr);
BOOL K2DBUS_StringIsValidErrorName(char const *apStr);
BOOL K2DBUS_StringIsValidBusName(char const *apStr);

K2STAT K2DBUS_Eat_AlignedBYTE(K2DBUS_PARSE *apParse, UINT8 *apRetByte);
K2STAT K2DBUS_Eat_AlignedBOOLEAN(K2DBUS_PARSE *apParse, BOOL *apRetBool);
K2STAT K2DBUS_Eat_AlignedDOUBLE(K2DBUS_PARSE *apParse, double *apRetDouble);
K2STAT K2DBUS_Eat_AlignedFLOAT(K2DBUS_PARSE *apParse, float *apRetFloat);
K2STAT K2DBUS_Eat_AlignedTOKEN(K2DBUS_PARSE *apParse, UINT32 *apRetToken);
K2STAT K2DBUS_Eat_AlignedINT32(K2DBUS_PARSE *apParse, INT32 *apRetInt32);
K2STAT K2DBUS_Eat_AlignedINT16(K2DBUS_PARSE *apParse, INT16 *apRetInt16);
K2STAT K2DBUS_Eat_AlignedUINT16(K2DBUS_PARSE *apParse, UINT16 *apRetUint16);
K2STAT K2DBUS_Eat_AlignedUINT64(K2DBUS_PARSE *apParse, UINT64 *apRetUint64);
K2STAT K2DBUS_Eat_AlignedUINT32(K2DBUS_PARSE *apParse, UINT32 *apRetUint32);
K2STAT K2DBUS_Eat_AlignedINT64(K2DBUS_PARSE *apParse, INT64 *apRetInt64);
K2STAT K2DBUS_Eat_AlignedSTRZ(K2DBUS_PARSE *apParse, char const **apRetStr, UINT32 *apRetStrLen);
K2STAT K2DBUS_Eat_SIG(K2DBUS_PARSE *apParse, char const **apRetSig, UINT32 *apRetSigLen);
K2STAT K2DBUS_Eat_AlignedARRAY(K2DBUS_PARSE *apParse, UINT32 *apRetCount, char const **apRetElemSig, UINT32 *apRetElemSigLen, UINT8 const **apRetElemsStart, UINT32 *apRetElemsLen);
K2STAT K2DBUS_Eat_AlignedDICTENT(K2DBUS_PARSE *apParse, char const **apRetElemSig, UINT32 *apRetElemSigLen, UINT32 *apRetElemLen);
K2STAT K2DBUS_Eat_AlignedSTRUCT(K2DBUS_PARSE *apParse, char const **apRetStructSig, UINT32 *apRetStructSigLen, UINT32 *apRetStructDataLen);
K2STAT K2DBUS_Eat_VARIANT(K2DBUS_PARSE *apParse, char const **apRetSig, UINT32 *apRetSigLen, UINT8 const **apRetVarData, UINT32 *apRetVarLen);

//
//------------------------------------------------------------------------
//

typedef struct _K2DBUS_PARSED_HDR K2DBUS_PARSED_HDR;
struct _K2DBUS_PARSED_HDR
{
    K2DBUS_MSGHDR const *   mpRaw;

    char const *            mpObjPath;
    UINT32                  mObjPathLen;

    char const *            mpInterface;
    UINT32                  mInterfaceLen;

    char const *            mpMember;
    UINT32                  mMemberLen;

    char const *            mpErrorName;
    UINT32                  mErrorNameLen;

    BOOL                    mHasReplySerial;
    UINT32                  mReplySerial;

    char const *            mpDestination;
    UINT32                  mDestinationLen;

    char const *            mpSender;
    UINT32                  mSenderLen;

    char const *            mpSignature;
    UINT32                  mSignatureLen;
};

K2STAT K2DBUS_EatHeader(UINT8 const **appStream, UINT32 *apStreamLeft, K2DBUS_PARSED_HDR *apRetParse);

K2STAT K2DBUS_Validate(K2DBUS_PARSE *apParse);

//
//------------------------------------------------------------------------
//

#ifdef __cplusplus
};   // extern "C"
#endif

#endif  // __K2ELF_H

